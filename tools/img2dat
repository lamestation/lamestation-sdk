#!/usr/bin/env python

import os, sys

from PIL import Image
import argparse


LS_SCREEN_W = 128
LS_SCREEN_H = 64

SCALEFACTOR = 4

PAGES = 8
ADDRESSES = 128
PIXELS_PER_ADDRESS = 8
BITS_PER_PIXEL = 2

BITS_PER_BLOCK = 8


DEFAULT_FRAME=(8,8)

def multiply_tuple(scalar,tup):
    return tuple([scalar*x for x in tup])


parser = argparse.ArgumentParser(description='Convert images to Propeller Spin data blocks for use with Lame Graphics.')

parser.add_argument('-m','--mode', nargs=1, metavar=('MODE'), choices=['sprite','font','tilemap'], default=['sprite'],
        help="""Indicates what the image is to be converted into:
            block - Image with no header, often used for tilemaps
            sprite - An image with custom width/height and that may have multiple frames
            font - A bitmap font to be used with lame_text
        """)
parser.add_argument('-b','--bits', nargs=1, metavar=('BITS'), type=int, choices=[2,8],default=[2],
        help="Bit depth of images.")

parser.add_argument('-f','--framesize', nargs=2, metavar=('WIDTH','HEIGHT'), type=int,
        help="Size of individual sprite frames (only needed for sprites).")

parser.add_argument('-d','--display', action='store_true',
        help="Show graphic comparison of old and new images.")

parser.add_argument('filenames', metavar='FILE', nargs='+', help='Files to convert')


args = parser.parse_args()

filenames = [ i for i in args.filenames if not os.path.splitext(i)[1] == '.dat' and os.path.isfile(i) ]
filenames = [ i for i in filenames if not os.path.splitext(i)[1] == '.txt' ]

if not filenames:
    print "No valid files selected"
else:
    for filename in filenames:
        newfilename = filename+".dat"

        try:
            im = Image.open(filename)
        except IOError:
            print filename, "is not a valid image file"
            sys.exit(1)

        im = im.convert("RGB")
        output_im = Image.new("RGB",im.size)
        output_txt = open(newfilename,'w')

        output_txt.write("gfx_%s\n" % os.path.splitext(os.path.basename(filename))[0])


        if args.mode[0] == 'sprite':

            # Check if framesize passed in arguments
            if args.framesize:
                framesize = tuple(args.framesize)
                if not framesize < im.size:
                    print "Frame is larger than image; exiting"
                    sys.exit(1)
            else:
                framesize = im.size


            # Calculate frameboost constant, the precalculated frame size so 
            # that jumping to a frame requires only one multiplication, not three.
            frameboost = (framesize[0]*BITS_PER_PIXEL*framesize[1]/PIXELS_PER_ADDRESS) & 0xFFFF
            dimensions = (framesize[0] & 0xFFFF , framesize[1] & 0xFFFF) 

            output_txt.write("word    %i" % frameboost + "  'frameboost\n")
            output_txt.write("word    %i, %i   'width, height\n" % dimensions )

        elif args.mode[0] == 'tilemap':
            framesize = DEFAULT_FRAME


        if args.bits[0] == 2:
            if not framesize[0] % 8 == 0:
                print "Error: frame size x must be multiple of 8. Aborting."
                sys.exit(1)


            if not framesize[1] %8 == 0:
                print "Error: frame size y must be multiple of 8. Aborting."
                sys.exit(1)


        wordcount = 0
        colordata = 0

        for frame_y in range(0,im.size[1]/framesize[1]):
            for frame_x in range(0,im.size[0]/framesize[0]):

                for py in range(0,framesize[1]):
                    for px in range(0,framesize[0]):

                        x = frame_x*framesize[0] + px
                        y = frame_y*framesize[1] + py

                        if x % BITS_PER_BLOCK == 0:
                            colordata = 0

                        colorchar = 0
                        pixeldata = im.getpixel((x,y))

                        if args.bits[0] == 2:
                            if type(pixeldata) is tuple:
                                coloravg = sum(pixeldata)/3

                            else:
                                coloravg = pixeldata
        # BLACK = 0
        # WHITE = 1
        # TRANSPARENT = 2
        # GRAY = 3

                            # Pink is the alpha color
                            if pixeldata == (255,0,255):
                                output_im.putpixel((x,y), (255, 0, 255))
                                colorchar = 2
                            else:
                                # if color is not black
                                if coloravg > 40:

                                    # if not white, gray
                                    if coloravg < 210:
                                        output_im.putpixel((x,y), (139, 138, 116))
                                        colorchar = 3
                                    else:
                                        output_im.putpixel((x,y), (255, 233, 166))
                                        colorchar = 1

                                else:
                                    ## if black
                                    output_im.putpixel((x,y), (23,43,66))
                                    colorchar = 0

                            colordata += (colorchar << ((x % BITS_PER_BLOCK)*2))


                            if x % BITS_PER_BLOCK == BITS_PER_BLOCK-1 or x == im.size[0]-1:
                                output_txt.write("$"+hex(colordata)[2:].zfill(BITS_PER_BLOCK/2))

                            if x % BITS_PER_BLOCK == 0:
                                if wordcount % (BITS_PER_BLOCK*2) == 0:
                                    output_txt.write("\nword    ")
                                else:
                                    if x < im.size[0]-1:
                                        output_txt.write(", ")

                                wordcount += 1







                        elif args.bits[0] == 8:
                            if type(pixeldata) is tuple:
                                r = pixeldata[0] >> 6 << 6
                                g = pixeldata[1] >> 6 << 6
                                b = pixeldata[2] >> 6 << 6
                                output_im.putpixel((x,y), (r, g, b))
                                colorchar = (r) + (g >> 2) + (b >> 4)
                            else:
                                print "Color data not in tuple format?"
                                sys.exit(1)

        output_txt.close()

        if args.display:
            # Create a canvas to paste both the input and output images onto
            output_canvas = Image.new("RGB",(im.size[0],im.size[1]*2))
            output_canvas.paste(im,(0,0))
            output_canvas.paste(output_im,(0,im.size[1]))

            # Then resize the canvas to make it easier to see
            output_canvas = output_canvas.resize(multiply_tuple(SCALEFACTOR,(im.size[0],im.size[1]*2)))
            output_canvas.show()

        print "'   Creating:",newfilename
        print "'  Bit depth:", args.bits[0]
        print "' Image Type:", args.mode[0]
        print "' Image size:",im.size
        print "' Frame size:",framesize
        print "'     Frames:",im.size[1]/framesize[1],",",im.size[0]/framesize[0]
        print "'------------------- COPY AFTER THIS LINE --------------------"

        print open(newfilename,'r').read()
